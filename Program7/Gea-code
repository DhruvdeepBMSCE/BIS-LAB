import random
import math

# Cities (x, y coordinates)
cities = [(0,0), (1,3), (4,3), (6,1), (3,0)]

# Distance between two cities
def dist(a, b):
    return math.sqrt((a[0]-b[0])**2 + (a[1]-b[1])**2)

# Total route distance
def route_distance(route):
    return sum(dist(cities[route[i]], cities[route[(i+1)%len(route)]]) for i in range(len(route)))

# Fitness (shorter distance = better)
def fitness(route):
    return 1 / route_distance(route)

# Create initial population
def init_population(size):
    base = list(range(len(cities)))
    return [random.sample(base, len(base)) for _ in range(size)]

# Selection (roulette wheel)
def select(pop, fits):
    total = sum(fits)
    pick = random.uniform(0, total)
    curr = 0
    for i, f in enumerate(fits):
        curr += f
        if curr > pick:
            return pop[i]

# Crossover (ordered crossover)
def crossover(p1, p2):
    a, b = sorted(random.sample(range(len(p1)), 2))
    child = [None]*len(p1)
    child[a:b] = p1[a:b]
    ptr = 0
    for x in p2:
        if x not in child:
            while child[ptr] is not None:
                ptr += 1
            child[ptr] = x
    return child

# Mutation (swap two cities)
def mutate(route):
    i, j = random.sample(range(len(route)), 2)
    route[i], route[j] = route[j], route[i]
    return route

# Main GA loop
POP_SIZE = 4
GENERATIONS = 5
pop = init_population(POP_SIZE)

for gen in range(GENERATIONS):
    fits = [fitness(r) for r in pop]
    best_route = pop[fits.index(max(fits))]
    print(f"Gen {gen+1}: Best distance = {route_distance(best_route):.2f}, Route = {best_route}")

    new_pop = []
    for _ in range(POP_SIZE):
        p1, p2 = select(pop, fits), select(pop, fits)
        child = crossover(p1, p2)
        if random.random() < 0.2:
            child = mutate(child)
        new_pop.append(child)
    pop = new_pop

# Final Result
fits = [fitness(r) for r in pop]
best_route = pop[fits.index(max(fits))]
print("\nFinal Best Route:", best_route)
print("Final Best Distance:", route_distance(best_route))
